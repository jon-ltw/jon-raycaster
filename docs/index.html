<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Cyberpunk Raycaster - Fullscreen FPS</title>
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#000; color:#0f0; font-family:monospace; }
    #startScreen, #endScreen {
      position:absolute; inset:0;
      display:flex; flex-direction:column;
      justify-content:center; align-items:center;
      background:rgba(0,0,0,0.85);
      z-index:10;
    }
    #startScreen input, #startScreen button {
      font-size:18px; padding:8px 16px; margin:8px;
    }
    #notice { color:#f00; margin-top:8px; }
    #gameCanvas {
      position:absolute; top:0; left:0;
      width:100%; height:100%;
      cursor:crosshair;
      display:none;
    }
    #ui {
      position:absolute; top:10px; left:50%; transform:translateX(-50%);
      z-index:5; font-size:18px;
      display:none;
    }
    #endScreen {
      position:absolute; inset:0;
      display:flex; justify-content:center; align-items:center;
      font-size:24px; text-align:center;
      background:rgba(0,0,0,0.85);
      z-index:10;
      display:none;
    }
  </style>
</head>
<body>
  <div id="startScreen">
    <h1>Cyberpunk Raycaster</h1>
    <div>Enter your name:</div>
    <input id="nameInput" type="text" placeholder="Player Name" />
    <button id="startBtn">Start Game</button>
    <div id="notice"></div>
  </div>
  <canvas id="gameCanvas"></canvas>
  <div id="ui"></div>
  <div id="endScreen"></div>

  <script>
    // Element references
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const ui = document.getElementById('ui');
    const startScreen = document.getElementById('startScreen');
    const endScreen = document.getElementById('endScreen');
    const notice = document.getElementById('notice');

    // Game state
    let playerName = '';
    let gameStarted = false;
    let gameOver = false;

    // Resize canvas to fill window
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);

    // Start button handler
    document.getElementById('startBtn').addEventListener('click', () => {
      playerName = document.getElementById('nameInput').value.trim() || 'Player';
      startScreen.style.display = 'none';
      resizeCanvas();
      canvas.style.display = 'block';
      ui.style.display = 'block';
      gameStarted = true;
      initGame();
      loop();
    });

    // Pointer lock + shoot
    canvas.addEventListener('click', () => {
      if (!gameStarted || gameOver) return;
      canvas.requestPointerLock?.();
      bullets.push({ x: player.x, y: player.y, angle: player.angle, alive: true });
    });
    document.addEventListener('pointerlockerror', () => {
      notice.textContent = 'Pointer lock denied. Click to retry.';
    });
    document.addEventListener('pointerlockchange', () => {
      if (document.pointerLockElement === canvas) notice.textContent = '';
    });

    // Map configuration
    const mapCols = 32, mapRows = 32, tileSize = 64;
    let map = [], freeCells = [];

    // Player and view
    let player;
    const fov = Math.PI/3;
    let numRays, wallDistances;

    // Enemies and bullets
    let enemies, bullets;
    const enemySpeed = 1, bulletSpeed = 10;
    let kills = 0;

    function initGame() {
      // Build map
      map = Array.from({ length: mapRows }, (_, y) =>
        Array.from({ length: mapCols }, (_, x) =>
          (y === 0 || x === 0 || y === mapRows-1 || x === mapCols-1) ? 1 : (Math.random() < 0.1)
        )
      );
      freeCells = [];
      for (let y = 1; y < mapRows-1; y++) {
        for (let x = 1; x < mapCols-1; x++) {
          if (map[y][x] === 0) freeCells.push({ x: x*tileSize + tileSize/2, y: y*tileSize + tileSize/2 });
        }
      }
      player = { x: tileSize*2, y: tileSize*2, angle: 0, speed: 2 };
      numRays = Math.ceil(canvas.width / 2);
      wallDistances = new Array(numRays);
      enemies = Array.from({ length: 5 }, () => ({ x:0, y:0, dir:0, alive:true, killCount:0, respawnAt:null })).map(e => { spawnEnemy(e); return e; });
      bullets = [];
      kills = 0;
      updateUI();
    }

    function spawnEnemy(e) {
      const c = freeCells[Math.floor(Math.random()*freeCells.length)];
      Object.assign(e, { x:c.x, y:c.y, dir:Math.random()*2*Math.PI, alive:true });
    }

    function updateUI() {
      const alive = enemies.filter(e => e.alive).length;
      ui.textContent = `Use WASD to move, click to shoot | Kills: ${kills} | Enemies Alive: ${alive}/${enemies.length}`;
    }

    // Input
    const keys = {};
    document.addEventListener('keydown', e => keys[e.code] = true);
    document.addEventListener('keyup', e => keys[e.code] = false);
    document.addEventListener('mousemove', e => {
      if (document.pointerLockElement === canvas) player.angle += e.movementX * 0.002;
    });

    // Game loop functions
    function updateBullets() {
      bullets.forEach(b => {
        if (!b.alive) return;
        b.x += Math.cos(b.angle) * bulletSpeed;
        b.y += Math.sin(b.angle) * bulletSpeed;
        const cx = Math.floor(b.x/tileSize), cy = Math.floor(b.y/tileSize);
        if (map[cy]?.[cx]) { b.alive = false; return; }
        enemies.forEach(e => {
          if (e.alive && ((b.x-e.x)**2 + (b.y-e.y)**2) < (tileSize/4)**2) {
            b.alive = false;
            e.alive = false;
            e.killCount++;
            kills++;
            if (e.killCount < 3) e.respawnAt = Date.now() + 1500;
            updateUI();
          }
        });
      });
      bullets = bullets.filter(b => b.alive);
    }

    function updateEnemies() {
      enemies.forEach(e => {
        if (!e.alive) return;
        const vx = Math.cos(e.dir) * enemySpeed;
        const vy = Math.sin(e.dir) * enemySpeed;
        const nx = e.x + vx, ny = e.y + vy;
        const cx = Math.floor(nx/tileSize), cy = Math.floor(ny/tileSize);
        if (!map[cy]?.[cx]) { e.x = nx; e.y = ny; } else { e.dir = Math.random()*2*Math.PI; }
        if (Math.random() < 0.01) e.dir += (Math.random()-0.5);
      });
    }

    function handleRespawn() {
      const now = Date.now();
      enemies.forEach(e => {
        if (!e.alive && e.respawnAt && now >= e.respawnAt) spawnEnemy(e);
      });
    }

    function updatePlayer() {
      let dx = 0, dy = 0;
      if (keys['KeyW']) { dx += Math.cos(player.angle)*player.speed; dy += Math.sin(player.angle)*player.speed; }
      if (keys['KeyS']) { dx -= Math.cos(player.angle)*player.speed; dy -= Math.sin(player.angle)*player.speed; }
      if (keys['KeyA']) { dx += Math.cos(player.angle-Math.PI/2)*player.speed; dy += Math.sin(player.angle-Math.PI/2)*player.speed; }
      if (keys['KeyD']) { dx += Math.cos(player.angle+Math.PI/2)*player.speed; dy += Math.sin(player.angle+Math.PI/2)*player.speed; }
      const nx = player.x + dx, ny = player.y + dy;
      const tx = Math.floor(player.y/tileSize), ty = Math.floor(nx/tileSize);
      if (!map[Math.floor(player.y/tileSize)]?.[ty] && !enemies.some(e=> e.alive && ((nx-e.x)**2+(player.y-e.y)**2) < (tileSize*0.6)**2)) player.x = nx;
      if (!map[Math.floor(ny/tileSize)]?.[Math.floor(player.x/tileSize)] && !enemies.some(e=> e.alive && ((player.x-e.x)**2+(ny-e.y)**2) < (tileSize*0.6)**2)) player.y = ny;
    }

    function draw3D() {
      const w = canvas.width / numRays;
      const halfH = canvas.height / 2;
      ctx.fillStyle = '#002'; ctx.fillRect(0, 0, canvas.width, halfH);
      ctx.fillStyle = '#444'; ctx.fillRect(0, halfH, canvas.width, halfH);
      for (let i = 0; i < numRays; i++) {
        const rayScreen = (i - numRays/2) * w;
        const rayAngle = player.angle + Math.atan(rayScreen/(canvas.width/(2*Math.tan(fov/2))));
        let dist = 0, hit = false;
        while (!hit && dist < mapCols*tileSize) {
          dist += 5;
          const tx = Math.floor((player.x+Math.cos(rayAngle)*dist)/tileSize);
          const ty = Math.floor((player.y+Math.sin(rayAngle)*dist)/tileSize);
          if (map[ty]?.[tx]) hit = true;
        }
        const corrected = dist * Math.cos(rayAngle-player.angle);
        wallDistances[i] = corrected;
        const height = (tileSize*canvas.height) / corrected;
        const shade = Math.max(0,255 - corrected*0.3)|0;
        ctx.fillStyle = `rgb(${shade},0,${shade})`;
        ctx.fillRect(i*w, halfH-height/2, w+1, height);
      }
      enemies.forEach(e => {
        if (!e.alive) return;
        const dx=e.x-player.x, dy=e.y-player.y;
        const dist = Math.hypot(dx,dy);
        const ang = Math.atan2(dy,dx) - player.angle;
        const proj = Math.tan(ang)*(canvas.width/(2*Math.tan(fov/2)));
        const screenX = canvas.width/2 + proj;
        const col = Math.floor(screenX/w);
        if (col>=0 && col<numRays && dist<wallDistances[col]) {
          const size = (tileSize*canvas.height)/dist;
          ctx.fillStyle = 'red';
          ctx.fillRect(screenX-size/2, halfH-size/2, size, size);
        }
      });
      bullets.forEach(b => {
        const dx=b.x-player.x, dy=b.y-player.y;
        const dist = Math.hypot(dx,dy);
        const ang = Math.atan2(dy,dx) - player.angle;
        const proj = Math.tan(ang)*(canvas.width/(2*Math.tan(fov/2)));
        const screenX = canvas.width/2 + proj;
        const col = Math.floor(screenX/w);
        if (col>=0 && col<numRays && dist<wallDistances[col]) {
          ctx.fillStyle = '#fff'; ctx.fillRect(screenX-2, halfH-2,4,4);
        }
      });
    }

    function loop() {
      updatePlayer();
      updateBullets();
      updateEnemies();
      handleRespawn();
      updateUI();
      draw3D();
      if (!gameOver && enemies.every(e=>e.killCount>=3)) {
        gameOver = true;
        endScreen.textContent = `Thank you ${playerName} for playing Jon's game`;
        endScreen.style.display = 'flex';
      } else if (!gameOver) {
        requestAnimationFrame(loop);
      }
    }
  </script>
</body>
</html>
