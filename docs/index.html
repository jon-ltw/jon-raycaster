<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Cyberpunk Raycaster - Fullscreen FPS</title>
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#000; color:#0f0; font-family:monospace; }
    #startScreen, #endScreen {
      position:absolute; inset:0;
      display:flex; flex-direction:column;
      justify-content:center; align-items:center;
      background:rgba(0,0,0,0.85);
      z-index:10;
    }
    #startScreen input, #startScreen button {
      font-size:18px; padding:8px 16px; margin:8px;
    }
    #notice { color:#f00; margin-top:8px; }
    #gameCanvas {
      position:absolute; top:0; left:0;
      width:100%; height:100%;
      cursor:crosshair;
      display:none;
    }
    #ui {
      position:absolute; top:10px; left:50%; transform:translateX(-50%);
      z-index:5; font-size:18px;
      display:none;
    }
    #endScreen {
      position:absolute; inset:0;
      display:flex; justify-content:center; align-items:center;
      font-size:24px; text-align:center;
      background:rgba(0,0,0,0.85);
      z-index:10;
      display:none;
    }
  </style>
</head>
<body>
  <div id="startScreen">
    <h1>Cyberpunk Raycaster</h1>
    <div>Enter your name:</div>
    <input id="nameInput" type="text" placeholder="Player Name" />
    <button id="startBtn">Start Game</button>
    <div id="notice"></div>
  </div>
  <canvas id="gameCanvas"></canvas>
  <div id="ui"></div>
  <div id="endScreen"></div>

  <script>
    // Element references
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const ui = document.getElementById('ui');
    const startScreen = document.getElementById('startScreen');
    const endScreen = document.getElementById('endScreen');
    const notice = document.getElementById('notice');

    // Game state
    let playerName = '';
    let gameStarted = false;
    let gameOver = false;

    // Resize canvas to fill window
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);

    // Start button handler
    document.getElementById('startBtn').addEventListener('click', () => {
      playerName = document.getElementById('nameInput').value.trim() || 'Player';
      startScreen.style.display = 'none';
      resizeCanvas();
      canvas.style.display = 'block';
      ui.style.display = 'block';
      gameStarted = true;
      initGame();
      loop();
    });

    // Pointer lock + shoot
    canvas.addEventListener('click', () => {
      if (!gameStarted || gameOver) return;
      canvas.requestPointerLock?.();
      bullets.push({ x: player.x, y: player.y, angle: player.angle, alive: true });
    });
    document.addEventListener('pointerlockerror', () => {
      notice.textContent = 'Pointer lock denied. Click to retry.';
    });
    document.addEventListener('pointerlockchange', () => {
      if (document.pointerLockElement === canvas) notice.textContent = '';
    });

    // Map config
    const mapCols = 32, mapRows = 32, tileSize = 64;
    let map = [], freeCells = [];

    // View/Player
    let player, numRays, maxDepth, wallDistances;
    const fov = Math.PI/3;

    // Entities
    let enemies, bullets;
    const enemySpeed = 1, bulletSpeed = 10;
    let kills = 0;

    function initGame() {
      // Build map array
      map = Array.from({ length: mapRows }, (_, y) =>
        Array.from({ length: mapCols }, (_, x) =>
          (y===0||x===0||y===mapRows-1||x===mapCols-1) ? 1 : (Math.random()<0.1?1:0)
        )
      );
      // Collect free cells
      freeCells = [];
      for (let y=1; y<mapRows-1; y++) {
        for (let x=1; x<mapCols-1; x++) {
          if (!map[y][x]) freeCells.push({ x:x*tileSize+tileSize/2, y:y*tileSize+tileSize/2 });
        }
      }
      // Initialize player
      player = { x: tileSize*2, y: tileSize*2, angle:0, speed:2 };
      numRays = Math.ceil(canvas.width/2);
      maxDepth = tileSize * Math.max(mapCols, mapRows);
      wallDistances = new Array(numRays);
      // Spawn enemies
      enemies = Array.from({ length:5 }, () => ({ x:0,y:0,dir:0,alive:true,killCount:0,respawnAt:null }));
      enemies.forEach(e => spawnEnemy(e));
      // Bullets
      bullets = [];
      kills = 0;
      updateUI();
    }

    function spawnEnemy(e) {
      const c = freeCells[Math.floor(Math.random()*freeCells.length)];
      Object.assign(e, { x:c.x, y:c.y, dir:Math.random()*2*Math.PI, alive:true });
    }

    function updateUI() {
      const alive = enemies.filter(e => e.alive).length;
      ui.textContent = `Use WASD to move, click to shoot | Kills: ${kills} | Enemies Alive: ${alive}/${enemies.length}`;
    }

    // Input
    const keys = {};
    document.addEventListener('keydown', e=>keys[e.code]=true);
    document.addEventListener('keyup', e=>keys[e.code]=false);
    document.addEventListener('mousemove', e=>{
      if (document.pointerLockElement===canvas) player.angle += e.movementX*0.002;
    });

    // Main loop functions
    function updateBullets() {
      bullets.forEach(b=>{
        if (!b.alive) return;
        b.x += Math.cos(b.angle)*bulletSpeed;
        b.y += Math.sin(b.angle)*bulletSpeed;
        const cx=Math.floor(b.x/tileSize), cy=Math.floor(b.y/tileSize);
        if (map[cy]?.[cx]) { b.alive=false; return; }
        enemies.forEach(e=>{
          if (e.alive && ((b.x-e.x)**2+(b.y-e.y)**2) < (tileSize/4)**2) {
            b.alive=false; e.alive=false; e.killCount++; kills++;
            if (e.killCount<3) e.respawnAt=Date.now()+1500;
            updateUI();
          }
        });
      });
      bullets = bullets.filter(b=>b.alive);
    }

    function updateEnemies() {
      enemies.forEach(e=>{
        if (!e.alive) return;
        const vx=Math.cos(e.dir)*enemySpeed, vy=Math.sin(e.dir)*enemySpeed;
        const nx=e.x+vx, ny=e.y+vy;
        const cx=Math.floor(nx/tileSize), cy=Math.floor(ny/tileSize);
        if (!map[cy]?.[cx]) { e.x=nx; e.y=ny; } else e.dir=Math.random()*2*Math.PI;
        if (Math.random()<0.01) e.dir+=(Math.random()-0.5);
      });
    }

    function handleRespawn() {
      const now=Date.now();
      enemies.forEach(e=>{ if (!e.alive && e.respawnAt && now>=e.respawnAt) spawnEnemy(e); });
    }

    function updatePlayer() {
      let dx=0, dy=0;
      if (keys['KeyW']) { dx+=Math.cos(player.angle)*player.speed; dy+=Math.sin(player.angle)*player.speed; }
      if (keys['KeyS']) { dx-=Math.cos(player.angle)*player.speed; dy-=Math.sin(player.angle)*player.speed; }
      if (keys['KeyA']) { dx+=Math.cos(player.angle-Math.PI/2)*player.speed; dy+=Math.sin(player.angle-Math.PI/2)*player.speed; }
      if (keys['KeyD']) { dx+=Math.cos(player.angle+Math.PI/2)*player.speed; dy+=Math.sin(player.angle+Math.PI/2)*player.speed; }
      const nx=player.x+dx, ny=player.y+dy;
      if (!map[Math.floor(player.y/tileSize)]?.[Math.floor(nx/tileSize)]) player.x=nx;
      if (!map[Math.floor(ny/tileSize)]?.[Math.floor(player.x/tileSize)]) player.y=ny;
    }

    function draw3D() {
      const w=canvas.width/numRays;
      const halfH=canvas.height/2;
      ctx.fillStyle='#002'; ctx.fillRect(0,0,canvas.width,halfH);
      ctx.fillStyle='#444'; ctx.fillRect(0,halfH,canvas.width,halfH);
      for (let i=0;i<numRays;i++) {
        const rayScreen=(i-numRays/2)*w;
        const rayAngle=player.angle+Math.atan(rayScreen/(canvas.width/(2*Math.tan(fov/2))));
        let dist=0,hit=false;
        while(!hit&&dist<maxDepth){ dist+=5;
          const tx=Math.floor((player.x+Math.cos(rayAngle)*dist)/tileSize);
          const ty=Math.floor((player.y+Math.sin(rayAngle)*dist)/tileSize);
          if(map[ty]?.[tx]) hit=true;
        }
        const corrected=dist*Math.cos(rayAngle-player.angle);
        wallDistances[i]=corrected;
        const height=(tileSize*canvas.height)/corrected;
        const shade=Math.max(50,255-corrected*0.3)|0;
        ctx.fillStyle=`rgb(${shade},0,${shade})`;
        ctx.fillRect(i*w,halfH-height/2,w+1,height);
      }
      // Draw enemies & bullets omitted for brevity
    }

    function loop() {
      updatePlayer(); updateBullets(); updateEnemies(); handleRespawn(); updateUI(); draw3D();
      if (!gameOver && enemies.every(e=>e.killCount>=3)) {
        gameOver=true; endScreen.textContent=`Thank you ${playerName} for playing Jon's game`; endScreen.style.display='flex';
      } else if(!gameOver) requestAnimationFrame(loop);
    }
  </script>
</body>
</html>
