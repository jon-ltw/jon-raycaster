<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Cyberpunk Raycaster with Start Screen</title>
  <style>
    body { margin:0; overflow:hidden; background:#000; color:#0f0; font:16px monospace; }
    #startScreen, #endScreen { position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); display:flex; justify-content:center; align-items:center; flex-direction:column; }
    #startScreen input { font-size:16px; padding:4px; margin:8px; }
    #startScreen button { font-size:16px; padding:6px 12px; }
    #gameCanvas { display:none; }
    #ui { position:absolute; top:10px; left:10px; display:none; }
    #endScreen { display:none; text-align:center; font-size:24px; }
  </style>
</head>
<body>
  <div id="startScreen">
    <div>Enter your name:</div>
    <input id="nameInput" type="text" placeholder="Player Name" />
    <button id="startBtn">Start Game</button>
  </div>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <div id="ui"></div>
  <div id="endScreen"></div>
  <script>
    // Suppress MetaMask connection errors from external plugins
    window.addEventListener('error', e => {
      if (e.message && e.message.includes('MetaMask')) {
        e.preventDefault();
      }
    }, true);
    window.addEventListener('unhandledrejection', e => {
      if (e.reason && e.reason.message && e.reason.message.includes('MetaMask')) {
        e.preventDefault();
      }
    }, true);

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const ui = document.getElementById('ui');
    const startScreen = document.getElementById('startScreen');
    const endScreen = document.getElementById('endScreen');
    let playerName = '';
    let gameStarted = false;
    let gameOver = false;

    document.getElementById('startBtn').addEventListener('click', startGame);
    function startGame() {
      playerName = document.getElementById('nameInput').value || 'Player';
      startScreen.style.display = 'none';
      canvas.style.display = 'block';
      ui.style.display = 'block';
      gameStarted = true;
      updateUI();
      loop();
    }

    // Map setup
    const mapCols = 32, mapRows = 32, tileSize = 64;
    let map = [];
    for (let y = 0; y < mapRows; y++) {
      map[y] = [];
      for (let x = 0; x < mapCols; x++) {
        map[y][x] = (y === 0 || x === 0 || y === mapRows - 1 || x === mapCols - 1)
          ? 1
          : (Math.random() < 0.1 ? 1 : 0);
      }
    }
    const freeCells = [];
    for (let y = 1; y < mapRows - 1; y++) {
      for (let x = 1; x < mapCols - 1; x++) {
        if (map[y][x] === 0) freeCells.push({ x: x * tileSize + tileSize / 2, y: y * tileSize + tileSize / 2 });
      }
    }

    // Player state
    const player = { x: tileSize * 2, y: tileSize * 2, angle: 0, speed: 2 };
    const fov = Math.PI / 3, numRays = 200;
    const maxDepth = tileSize * Math.max(mapCols, mapRows);
    let wallDistances = new Array(numRays);

    // Enemies
    let enemies = [];
    const enemySpeed = 1;
    function spawnEnemy(e) {
      const cell = freeCells[Math.floor(Math.random() * freeCells.length)];
      e.x = cell.x; e.y = cell.y;
      e.alive = true; e.respawnAt = null;
      e.dir = Math.random() * 2 * Math.PI;
      e.killCount = e.killCount || 0;
    }
    for (let i = 0; i < 5; i++) {
      let e = { killCount: 0 };
      spawnEnemy(e);
      enemies.push(e);
    }
    let kills = 0;

    // Compass target lock
    let compassTarget = null;

    // UI update
    function updateUI() {
      const alive = enemies.filter(e => e.alive).length;
      ui.innerText = `Use WASD/Arrows to move, mouse to look, click to shoot | Kills: ${kills} | Enemies Alive: ${alive}/${enemies.length}`;
    }

    // Input & bullets
    const keys = {};
    const bullets = [];
    const bulletSpeed = 10;
    let lastMouseX = null;
    window.addEventListener('keydown', e => keys[e.code] = true);
    window.addEventListener('keyup', e => keys[e.code] = false);
    canvas.addEventListener('mouseenter', e => lastMouseX = e.clientX);
    canvas.addEventListener('mouseleave', () => lastMouseX = null);
    canvas.addEventListener('mousemove', e => { if (lastMouseX !== null) player.angle += (e.clientX - lastMouseX) * 0.002; lastMouseX = e.clientX; });
    canvas.addEventListener('mousedown', () => bullets.push({ x: player.x, y: player.y, angle: player.angle, alive: true }));

    // Update bullets
    function updateBullets() {
      for (let b of bullets) {
        if (!b.alive) continue;
        b.x += Math.cos(b.angle) * bulletSpeed;
        b.y += Math.sin(b.angle) * bulletSpeed;
        const cx = Math.floor(b.x / tileSize), cy = Math.floor(b.y / tileSize);
        if (map[cy]?.[cx] === 1) { b.alive = false; continue; }
        for (let e of enemies) {
          if (e.alive) {
            const dx = b.x - e.x, dy = b.y - e.y;
            if (dx * dx + dy * dy < (tileSize / 3) ** 2) {
              b.alive = false; e.alive = false; e.killCount++; kills++;
              if (e.killCount < 3) e.respawnAt = Date.now() + 1000;
              if (compassTarget === e) compassTarget = null;
              updateUI();
              break;
            }
          }
        }
      }
      for (let i = bullets.length - 1; i >= 0; i--) if (!bullets[i].alive) bullets.splice(i,1);
    }

    // Update enemies with map collision
    function updateEnemies() {
      for (let e of enemies) {
        if (!e.alive) continue;
        const dx = Math.cos(e.dir) * enemySpeed;
        const nx = e.x + dx;
        const cx = Math.floor(nx/tileSize), cy = Math.floor(e.y/tileSize);
        if (map[cy]?.[cx] === 0) e.x = nx; else e.dir = Math.random()*2*Math.PI;
        const dy = Math.sin(e.dir) * enemySpeed;
        const ny = e.y + dy;
        const cx2 = Math.floor(e.x/tileSize), cy2 = Math.floor(ny/tileSize);
        if (map[cy2]?.[cx2] === 0) e.y = ny; else e.dir = Math.random()*2*Math.PI;
        if (Math.random() < 0.01) e.dir += (Math.random()-0.5);
      }
    }

    // Respawn logic
    function handleRespawn() {
      const now = Date.now();
      for (let e of enemies) if (!e.alive && e.respawnAt && now >= e.respawnAt) spawnEnemy(e);
    }

    // Prevent player-enemy overlap
    function collidesWithEnemy(x, y) {
      for (let e of enemies) {
        if (!e.alive) continue;
        const dx = x - e.x, dy = y - e.y;
        if (dx * dx + dy * dy < (tileSize * 0.6) ** 2) return true;
      }
      return false;
    }

    // Draw UI elements
    function drawGun() {
      const cw = canvas.width, ch = canvas.height;
      ctx.fillStyle = '#444';
      ctx.fillRect(cw/2-5, ch-80, 10,40);
      ctx.fillRect(cw/2-20, ch-60, 40,20);
      ctx.fillRect(cw/2+10, ch-40, 10,20);
    }

    function drawCompass() {
      if (!compassTarget || !compassTarget.alive) {
        let nearest = null, md = Infinity;
        for (let e of enemies) if (e.alive) {
          const d = Math.hypot(e.x-player.x, e.y-player.y);
          if (d < md) { md = d; nearest = e; }
        }
        compassTarget = nearest;
      }
      if (!compassTarget) return;
      let ra = Math.atan2(compassTarget.y-player.y, compassTarget.x-player.x) - player.angle;
      ra = ((ra + Math.PI) % (2 * Math.PI)) - Math.PI;
      const cx = canvas.width/2, cy = 80, L = 40;
      const ex = cx + Math.sin(ra) * L, ey = cy - Math.cos(ra) * L;
      ctx.strokeStyle = '#0f0'; ctx.lineWidth = 4;
      ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(ex, ey); ctx.stroke();
      ctx.fillStyle = '#0f0';
      const s = 8;
      const a1 = ra + Math.PI - Math.PI/6, a2 = ra + Math.PI + Math.PI/6;
      const x1 = ex + Math.sin(a1) * s, y1 = ey - Math.cos(a1) * s;
      const x2 = ex + Math.sin(a2) * s, y2 = ey - Math.cos(a2) * s;
      ctx.beginPath(); ctx.moveTo(ex, ey); ctx.lineTo(x1, y1); ctx.lineTo(x2, y2); ctx.closePath(); ctx.fill();
    }

    function render3D() {
      const hh = canvas.height/2;
      ctx.fillStyle = '#001020'; ctx.fillRect(0, 0, canvas.width, hh);
      ctx.fillStyle = '#202020'; ctx.fillRect(0, hh, canvas.width, hh);
      const w = canvas.width / numRays;
      for (let i = 0; i < numRays; i++) {
        const sp = (-numRays/2 + i) * w;
        const ra = player.angle + Math.atan(sp / (canvas.width/(2*Math.tan(fov/2))));
        let d = 0, hit = false;
        while (!hit && d < maxDepth) {
          d += 5;
          const tx = Math.floor((player.x + Math.cos(ra)*d) / tileSize);
          const ty = Math.floor((player.y + Math.sin(ra)*d) / tileSize);
          if (map[ty]?.[tx] === 1) hit = true;
        }
        const cd = d * Math.cos(ra - player.angle);
        wallDistances[i] = cd;
        const height = (tileSize * canvas.height) / cd;
        const shade = Math.max(0, 255 - cd * 0.5);
        ctx.fillStyle = `rgb(${shade},0,${shade})`;
        ctx.fillRect(i*w, hh - height/2, w+1, height);
      }
      // Draw only visible enemies
      for (let e of enemies) if (e.alive) {
        const dx = e.x - player.x, dy = e.y - player.y;
        const d = Math.hypot(dx, dy);
        const ang = Math.atan2(dy, dx) - player.angle;
        const projX = Math.tan(ang) * (canvas.width/(2*Math.tan(fov/2)));
        let sx = canvas.width/2 + projX;
        sx = Math.max(0, Math.min(canvas.width, sx));
        const idx = Math.floor(sx / w);
        if (idx >= 0 && idx < numRays && d < wallDistances[idx]) {
          const size = (tileSize * canvas.height) / d;
          ctx.fillStyle = 'red';
          ctx.fillRect(sx - size/2, hh - size/2, size, size);
        }
      }
      // Draw only visible bullets
      for (let b of bullets) if (b.alive) {
        const dx = b.x - player.x, dy = b.y - player.y;
        const d = Math.hypot(dx, dy);
        const ang = Math.atan2(dy, dx) - player.angle;
        const projX = Math.tan(ang) * (canvas.width/(2*Math.tan(fov/2)));
        let sx = canvas.width/2 + projX;
        sx = Math.max(0, Math.min(canvas.width, sx));
        const idx = Math.floor(sx / w);
        if (idx >= 0 && idx < numRays && d < wallDistances[idx]) {
          const size = 4;
          ctx.fillStyle = '#fff';
          ctx.fillRect(sx - size/2, hh - size/2, size, size);
        }
      }
      drawCompass();
      drawGun();
    }

    // Main loop
    function update() {
      if (!gameStarted || gameOver) return;
      let mvX = 0, mvY = 0;
      if (keys['KeyW'] || keys['ArrowUp']) { mvX += Math.cos(player.angle)*player.speed; mvY += Math.sin(player.angle)*player.speed; }
      if (keys['KeyS'] || keys['ArrowDown']) { mvX -= Math.cos(player.angle)*player.speed; mvY -= Math.sin(player.angle)*player.speed; }
      if (keys['KeyD'] || keys['ArrowRight']) { mvX += Math.cos(player.angle+Math.PI/2)*player.speed; mvY += Math.sin(player.angle+Math.PI/2)*player.speed; }
      if (keys['KeyA'] || keys['ArrowLeft']) { mvX -= Math.cos(player.angle+Math.PI/2)*player.speed; mvY -= Math.sin(player.angle+Math.PI/2)*player.speed; }
      const nx = player.x + mvX, ny = player.y + mvY;
      if (map[Math.floor(player.y/tileSize)]?.[Math.floor(nx/tileSize)]===0 && !collidesWithEnemy(nx,player.y)) player.x=nx;
      if (map[Math.floor(ny/tileSize)]?.[Math.floor(player.x/tileSize)]===0 && !collidesWithEnemy(player.x,ny)) player.y=ny;
      updateEnemies(); updateBullets(); handleRespawn(); updateUI(); render3D();
      if (enemies.every(e=>e.killCount>=3)) {
        gameOver = true;
        canvas.style.display = 'none';
        ui.style.display = 'none';
        endScreen.innerText = `Thank you ${playerName} for playing Jon's game`;
        endScreen.style.display = 'block';
      }
    }
    function loop() { update(); if (!gameOver) requestAnimationFrame(loop); }
  </script>
</body>
</html>
